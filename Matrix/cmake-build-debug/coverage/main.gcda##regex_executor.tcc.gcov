        -:    0:Source:/usr/include/c++/9/bits/regex_executor.tcc
        -:    0:Graph:/home/minerkow/Рабочий стол/2nd_Course/Matrix/cmake-build-debug/CMakeFiles/Matrix.dir/main.gcno
        -:    0:Data:/home/minerkow/Рабочий стол/2nd_Course/Matrix/cmake-build-debug/CMakeFiles/Matrix.dir/main.gcda
        -:    0:Runs:1
        -:    1:// class template regex -*- C++ -*-
        -:    2:
        -:    3:// Copyright (C) 2013-2019 Free Software Foundation, Inc.
        -:    4://
        -:    5:// This file is part of the GNU ISO C++ Library.  This library is free
        -:    6:// software; you can redistribute it and/or modify it under the
        -:    7:// terms of the GNU General Public License as published by the
        -:    8:// Free Software Foundation; either version 3, or (at your option)
        -:    9:// any later version.
        -:   10:
        -:   11:// This library is distributed in the hope that it will be useful,
        -:   12:// but WITHOUT ANY WARRANTY; without even the implied warranty of
        -:   13:// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -:   14:// GNU General Public License for more details.
        -:   15:
        -:   16:// Under Section 7 of GPL version 3, you are granted additional
        -:   17:// permissions described in the GCC Runtime Library Exception, version
        -:   18:// 3.1, as published by the Free Software Foundation.
        -:   19:
        -:   20:// You should have received a copy of the GNU General Public License and
        -:   21:// a copy of the GCC Runtime Library Exception along with this program;
        -:   22:// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
        -:   23:// <http://www.gnu.org/licenses/>.
        -:   24:
        -:   25:/**
        -:   26: *  @file bits/regex_executor.tcc
        -:   27: *  This is an internal header file, included by other library headers.
        -:   28: *  Do not attempt to use it directly. @headername{regex}
        -:   29: */
        -:   30:
        -:   31:namespace std _GLIBCXX_VISIBILITY(default)
        -:   32:{
        -:   33:_GLIBCXX_BEGIN_NAMESPACE_VERSION
        -:   34:
        -:   35:namespace __detail
        -:   36:{
        -:   37:  template<typename _BiIter, typename _Alloc, typename _TraitsT,
        -:   38:	   bool __dfs_mode>
       3*:   39:    bool _Executor<_BiIter, _Alloc, _TraitsT, __dfs_mode>::
        -:   40:    _M_search()
        -:   41:    {
       3*:   42:      if (_M_search_from_first())
       3*:   43:	return true;
    #####:   44:      if (_M_flags & regex_constants::match_continuous)
    #####:   45:	return false;
    #####:   46:      _M_flags |= regex_constants::match_prev_avail;
    #####:   47:      while (_M_begin != _M_end)
        -:   48:	{
    #####:   49:	  ++_M_begin;
    #####:   50:	  if (_M_search_from_first())
    #####:   51:	    return true;
        -:   52:	}
    #####:   53:      return false;
        -:   54:    }
------------------
_ZNSt8__detail9_ExecutorIPKcSaINSt7__cxx119sub_matchIS2_EEENS3_12regex_traitsIcEELb1EE9_M_searchEv:
        3:   39:    bool _Executor<_BiIter, _Alloc, _TraitsT, __dfs_mode>::
        -:   40:    _M_search()
        -:   41:    {
        3:   42:      if (_M_search_from_first())
        3:   42-block  0
        3:   43:	return true;
        3:   43-block  0
    #####:   44:      if (_M_flags & regex_constants::match_continuous)
    %%%%%:   44-block  0
    #####:   45:	return false;
    %%%%%:   45-block  0
    #####:   46:      _M_flags |= regex_constants::match_prev_avail;
    %%%%%:   46-block  0
    #####:   47:      while (_M_begin != _M_end)
    %%%%%:   47-block  0
    %%%%%:   47-block  1
        -:   48:	{
    #####:   49:	  ++_M_begin;
    #####:   50:	  if (_M_search_from_first())
    %%%%%:   50-block  0
    #####:   51:	    return true;
    %%%%%:   51-block  0
        -:   52:	}
    #####:   53:      return false;
    %%%%%:   53-block  0
        -:   54:    }
------------------
_ZNSt8__detail9_ExecutorIPKcSaINSt7__cxx119sub_matchIS2_EEENS3_12regex_traitsIcEELb0EE9_M_searchEv:
    #####:   39:    bool _Executor<_BiIter, _Alloc, _TraitsT, __dfs_mode>::
        -:   40:    _M_search()
        -:   41:    {
    #####:   42:      if (_M_search_from_first())
    %%%%%:   42-block  0
    #####:   43:	return true;
    %%%%%:   43-block  0
    #####:   44:      if (_M_flags & regex_constants::match_continuous)
    %%%%%:   44-block  0
    #####:   45:	return false;
    %%%%%:   45-block  0
    #####:   46:      _M_flags |= regex_constants::match_prev_avail;
    %%%%%:   46-block  0
    #####:   47:      while (_M_begin != _M_end)
    %%%%%:   47-block  0
    %%%%%:   47-block  1
        -:   48:	{
    #####:   49:	  ++_M_begin;
    #####:   50:	  if (_M_search_from_first())
    %%%%%:   50-block  0
    #####:   51:	    return true;
    %%%%%:   51-block  0
        -:   52:	}
    #####:   53:      return false;
    %%%%%:   53-block  0
        -:   54:    }
------------------
        -:   55:
        -:   56:  // The _M_main function operates in different modes, DFS mode or BFS mode,
        -:   57:  // indicated by template parameter __dfs_mode, and dispatches to one of the
        -:   58:  // _M_main_dispatch overloads.
        -:   59:  //
        -:   60:  // ------------------------------------------------------------
        -:   61:  //
        -:   62:  // DFS mode:
        -:   63:  //
        -:   64:  // It applies a Depth-First-Search (aka backtracking) on given NFA and input
        -:   65:  // string.
        -:   66:  // At the very beginning the executor stands in the start state, then it
        -:   67:  // tries every possible state transition in current state recursively. Some
        -:   68:  // state transitions consume input string, say, a single-char-matcher or a
        -:   69:  // back-reference matcher; some don't, like assertion or other anchor nodes.
        -:   70:  // When the input is exhausted and/or the current state is an accepting
        -:   71:  // state, the whole executor returns true.
        -:   72:  //
        -:   73:  // TODO: This approach is exponentially slow for certain input.
        -:   74:  //       Try to compile the NFA to a DFA.
        -:   75:  //
        -:   76:  // Time complexity: \Omega(match_length), O(2^(_M_nfa.size()))
        -:   77:  // Space complexity: \theta(match_results.size() + match_length)
        -:   78:  //
        -:   79:  template<typename _BiIter, typename _Alloc, typename _TraitsT,
        -:   80:	   bool __dfs_mode>
        3:   81:    bool _Executor<_BiIter, _Alloc, _TraitsT, __dfs_mode>::
        -:   82:    _M_main_dispatch(_Match_mode __match_mode, __dfs)
        -:   83:    {
        3:   84:      _M_has_sol = false;
        3:   85:      *_M_states._M_get_sol_pos() = _BiIter();
        3:   85-block  0
        3:   86:      _M_cur_results = _M_results;
        3:   87:      _M_dfs(__match_mode, _M_states._M_start);
        3:   88:      return _M_has_sol;
        -:   89:    }
        -:   90:
        -:   91:  // ------------------------------------------------------------
        -:   92:  //
        -:   93:  // BFS mode:
        -:   94:  //
        -:   95:  // Russ Cox's article (http://swtch.com/~rsc/regexp/regexp1.html)
        -:   96:  // explained this algorithm clearly.
        -:   97:  //
        -:   98:  // It first computes epsilon closure (states that can be achieved without
        -:   99:  // consuming characters) for every state that's still matching,
        -:  100:  // using the same DFS algorithm, but doesn't re-enter states (using
        -:  101:  // _M_states._M_visited to check), nor follow _S_opcode_match.
        -:  102:  //
        -:  103:  // Then apply DFS using every _S_opcode_match (in _M_states._M_match_queue)
        -:  104:  // as the start state.
        -:  105:  //
        -:  106:  // It significantly reduces potential duplicate states, so has a better
        -:  107:  // upper bound; but it requires more overhead.
        -:  108:  //
        -:  109:  // Time complexity: \Omega(match_length * match_results.size())
        -:  110:  //                  O(match_length * _M_nfa.size() * match_results.size())
        -:  111:  // Space complexity: \Omega(_M_nfa.size() + match_results.size())
        -:  112:  //                   O(_M_nfa.size() * match_results.size())
        -:  113:  template<typename _BiIter, typename _Alloc, typename _TraitsT,
        -:  114:	   bool __dfs_mode>
    #####:  115:    bool _Executor<_BiIter, _Alloc, _TraitsT, __dfs_mode>::
        -:  116:    _M_main_dispatch(_Match_mode __match_mode, __bfs)
        -:  117:    {
    #####:  118:      _M_states._M_queue(_M_states._M_start, _M_results);
    %%%%%:  118-block  0
    #####:  119:      bool __ret = false;
    #####:  120:      while (1)
    %%%%%:  120-block  0
        -:  121:	{
    #####:  122:	  _M_has_sol = false;
    #####:  123:	  if (_M_states._M_match_queue.empty())
    %%%%%:  123-block  0
    #####:  124:	    break;
    %%%%%:  124-block  0
    #####:  125:	  std::fill_n(_M_states._M_visited_states.get(), _M_nfa.size(), false);
    %%%%%:  125-block  0
    $$$$$:  125-block  1
    #####:  126:	  auto __old_queue = std::move(_M_states._M_match_queue);
    %%%%%:  126-block  0
    $$$$$:  126-block  1
    #####:  127:	  for (auto& __task : __old_queue)
    %%%%%:  127-block  0
    %%%%%:  127-block  1
    %%%%%:  127-block  2
        -:  128:	    {
    #####:  129:	      _M_cur_results = std::move(__task.second);
    #####:  130:	      _M_dfs(__match_mode, __task.first);
        -:  131:	    }
    #####:  132:	  if (__match_mode == _Match_mode::_Prefix)
    %%%%%:  132-block  0
    #####:  133:	    __ret |= _M_has_sol;
    %%%%%:  133-block  0
    #####:  134:	  if (_M_current == _M_end)
    %%%%%:  134-block  0
    #####:  135:	    break;
    %%%%%:  135-block  0
    #####:  136:	  ++_M_current;
    %%%%%:  136-block  0
        -:  137:	}
    #####:  138:      if (__match_mode == _Match_mode::_Exact)
    %%%%%:  138-block  0
    #####:  139:	__ret = _M_has_sol;
    %%%%%:  139-block  0
    #####:  140:      _M_states._M_match_queue.clear();
    %%%%%:  140-block  0
    #####:  141:      return __ret;
    %%%%%:  141-block  0
        -:  142:    }
        -:  143:
        -:  144:  // Return whether now match the given sub-NFA.
        -:  145:  template<typename _BiIter, typename _Alloc, typename _TraitsT,
        -:  146:	   bool __dfs_mode>
    #####:  147:    bool _Executor<_BiIter, _Alloc, _TraitsT, __dfs_mode>::
        -:  148:    _M_lookahead(_StateIdT __next)
        -:  149:    {
        -:  150:      // Backreferences may refer to captured content.
        -:  151:      // We may want to make this faster by not copying,
        -:  152:      // but let's not be clever prematurely.
    #####:  153:      _ResultsVec __what(_M_cur_results);
    #####:  154:      _Executor __sub(_M_current, _M_end, __what, _M_re, _M_flags);
    #####:  155:      __sub._M_states._M_start = __next;
    #####:  156:      if (__sub._M_search_from_first())
        -:  157:	{
    #####:  158:	  for (size_t __i = 0; __i < __what.size(); __i++)
    #####:  159:	    if (__what[__i].matched)
    #####:  160:	      _M_cur_results[__i] = __what[__i];
    #####:  161:	  return true;
        -:  162:	}
    #####:  163:      return false;
        -:  164:    }
------------------
_ZNSt8__detail9_ExecutorIPKcSaINSt7__cxx119sub_matchIS2_EEENS3_12regex_traitsIcEELb1EE12_M_lookaheadEl:
    #####:  147:    bool _Executor<_BiIter, _Alloc, _TraitsT, __dfs_mode>::
        -:  148:    _M_lookahead(_StateIdT __next)
        -:  149:    {
        -:  150:      // Backreferences may refer to captured content.
        -:  151:      // We may want to make this faster by not copying,
        -:  152:      // but let's not be clever prematurely.
    #####:  153:      _ResultsVec __what(_M_cur_results);
    %%%%%:  153-block  0
    $$$$$:  153-block  1
    #####:  154:      _Executor __sub(_M_current, _M_end, __what, _M_re, _M_flags);
    %%%%%:  154-block  0
    %%%%%:  154-block  1
    $$$$$:  154-block  2
    #####:  155:      __sub._M_states._M_start = __next;
    #####:  156:      if (__sub._M_search_from_first())
    %%%%%:  156-block  0
    %%%%%:  156-block  1
        -:  157:	{
    #####:  158:	  for (size_t __i = 0; __i < __what.size(); __i++)
    %%%%%:  158-block  0
    %%%%%:  158-block  1
    %%%%%:  158-block  2
    #####:  159:	    if (__what[__i].matched)
    %%%%%:  159-block  0
    #####:  160:	      _M_cur_results[__i] = __what[__i];
    %%%%%:  160-block  0
    #####:  161:	  return true;
    %%%%%:  161-block  0
        -:  162:	}
    #####:  163:      return false;
    %%%%%:  163-block  0
        -:  164:    }
------------------
_ZNSt8__detail9_ExecutorIPKcSaINSt7__cxx119sub_matchIS2_EEENS3_12regex_traitsIcEELb0EE12_M_lookaheadEl:
    #####:  147:    bool _Executor<_BiIter, _Alloc, _TraitsT, __dfs_mode>::
        -:  148:    _M_lookahead(_StateIdT __next)
        -:  149:    {
        -:  150:      // Backreferences may refer to captured content.
        -:  151:      // We may want to make this faster by not copying,
        -:  152:      // but let's not be clever prematurely.
    #####:  153:      _ResultsVec __what(_M_cur_results);
    %%%%%:  153-block  0
    $$$$$:  153-block  1
    #####:  154:      _Executor __sub(_M_current, _M_end, __what, _M_re, _M_flags);
    %%%%%:  154-block  0
    %%%%%:  154-block  1
    $$$$$:  154-block  2
    #####:  155:      __sub._M_states._M_start = __next;
    #####:  156:      if (__sub._M_search_from_first())
    %%%%%:  156-block  0
    %%%%%:  156-block  1
        -:  157:	{
    #####:  158:	  for (size_t __i = 0; __i < __what.size(); __i++)
    %%%%%:  158-block  0
    %%%%%:  158-block  1
    %%%%%:  158-block  2
    #####:  159:	    if (__what[__i].matched)
    %%%%%:  159-block  0
    #####:  160:	      _M_cur_results[__i] = __what[__i];
    %%%%%:  160-block  0
    #####:  161:	  return true;
    %%%%%:  161-block  0
        -:  162:	}
    #####:  163:      return false;
    %%%%%:  163-block  0
        -:  164:    }
------------------
        -:  165:
        -:  166:  // __rep_count records how many times (__rep_count.second)
        -:  167:  // this node is visited under certain input iterator
        -:  168:  // (__rep_count.first). This prevent the executor from entering
        -:  169:  // infinite loop by refusing to continue when it's already been
        -:  170:  // visited more than twice. It's `twice` instead of `once` because
        -:  171:  // we need to spare one more time for potential group capture.
        -:  172:  template<typename _BiIter, typename _Alloc, typename _TraitsT,
        -:  173:	   bool __dfs_mode>
      52*:  174:    void _Executor<_BiIter, _Alloc, _TraitsT, __dfs_mode>::
        -:  175:    _M_rep_once_more(_Match_mode __match_mode, _StateIdT __i)
        -:  176:    {
      52*:  177:      const auto& __state = _M_nfa[__i];
      52*:  178:      auto& __rep_count = _M_rep_count[__i];
      52*:  179:      if (__rep_count.second == 0 || __rep_count.first != _M_current)
        -:  180:	{
      52*:  181:	  auto __back = __rep_count;
      52*:  182:	  __rep_count.first = _M_current;
      52*:  183:	  __rep_count.second = 1;
      52*:  184:	  _M_dfs(__match_mode, __state._M_alt);
      52*:  185:	  __rep_count = __back;
        -:  186:	}
        -:  187:      else
        -:  188:	{
    #####:  189:	  if (__rep_count.second < 2)
        -:  190:	    {
    #####:  191:	      __rep_count.second++;
    #####:  192:	      _M_dfs(__match_mode, __state._M_alt);
    #####:  193:	      __rep_count.second--;
        -:  194:	    }
        -:  195:	}
      52*:  196:    }
------------------
_ZNSt8__detail9_ExecutorIPKcSaINSt7__cxx119sub_matchIS2_EEENS3_12regex_traitsIcEELb1EE16_M_rep_once_moreENS9_11_Match_modeEl:
       52:  174:    void _Executor<_BiIter, _Alloc, _TraitsT, __dfs_mode>::
        -:  175:    _M_rep_once_more(_Match_mode __match_mode, _StateIdT __i)
        -:  176:    {
       52:  177:      const auto& __state = _M_nfa[__i];
       52:  177-block  0
       52:  178:      auto& __rep_count = _M_rep_count[__i];
       52:  179:      if (__rep_count.second == 0 || __rep_count.first != _M_current)
       10:  179-block  0
        -:  180:	{
       52:  181:	  auto __back = __rep_count;
       52:  182:	  __rep_count.first = _M_current;
       52:  183:	  __rep_count.second = 1;
       52:  184:	  _M_dfs(__match_mode, __state._M_alt);
       52:  184-block  0
       52:  185:	  __rep_count = __back;
       52:  185-block  0
        -:  186:	}
        -:  187:      else
        -:  188:	{
    #####:  189:	  if (__rep_count.second < 2)
    %%%%%:  189-block  0
        -:  190:	    {
    #####:  191:	      __rep_count.second++;
    #####:  192:	      _M_dfs(__match_mode, __state._M_alt);
    %%%%%:  192-block  0
    #####:  193:	      __rep_count.second--;
        -:  194:	    }
        -:  195:	}
       52:  196:    }
       52:  196-block  0
------------------
_ZNSt8__detail9_ExecutorIPKcSaINSt7__cxx119sub_matchIS2_EEENS3_12regex_traitsIcEELb0EE16_M_rep_once_moreENS9_11_Match_modeEl:
    #####:  174:    void _Executor<_BiIter, _Alloc, _TraitsT, __dfs_mode>::
        -:  175:    _M_rep_once_more(_Match_mode __match_mode, _StateIdT __i)
        -:  176:    {
    #####:  177:      const auto& __state = _M_nfa[__i];
    %%%%%:  177-block  0
    #####:  178:      auto& __rep_count = _M_rep_count[__i];
    #####:  179:      if (__rep_count.second == 0 || __rep_count.first != _M_current)
    %%%%%:  179-block  0
        -:  180:	{
    #####:  181:	  auto __back = __rep_count;
    #####:  182:	  __rep_count.first = _M_current;
    #####:  183:	  __rep_count.second = 1;
    #####:  184:	  _M_dfs(__match_mode, __state._M_alt);
    %%%%%:  184-block  0
    #####:  185:	  __rep_count = __back;
    %%%%%:  185-block  0
        -:  186:	}
        -:  187:      else
        -:  188:	{
    #####:  189:	  if (__rep_count.second < 2)
    %%%%%:  189-block  0
        -:  190:	    {
    #####:  191:	      __rep_count.second++;
    #####:  192:	      _M_dfs(__match_mode, __state._M_alt);
    %%%%%:  192-block  0
    #####:  193:	      __rep_count.second--;
        -:  194:	    }
        -:  195:	}
    #####:  196:    }
    %%%%%:  196-block  0
------------------
        -:  197:
        -:  198:  // _M_alt branch is "match once more", while _M_next is "get me out
        -:  199:  // of this quantifier". Executing _M_next first or _M_alt first don't
        -:  200:  // mean the same thing, and we need to choose the correct order under
        -:  201:  // given greedy mode.
        -:  202:  template<typename _BiIter, typename _Alloc, typename _TraitsT,
        -:  203:	   bool __dfs_mode>
      52*:  204:    void _Executor<_BiIter, _Alloc, _TraitsT, __dfs_mode>::
        -:  205:    _M_handle_repeat(_Match_mode __match_mode, _StateIdT __i)
        -:  206:    {
      52*:  207:      const auto& __state = _M_nfa[__i];
        -:  208:
        -:  209:      // Greedy.
      52*:  210:      if (!__state._M_neg)
        -:  211:	{
      52*:  212:	  _M_rep_once_more(__match_mode, __i);
        -:  213:	  // If it's DFS executor and already accepted, we're done.
       52:  214:	  if (!__dfs_mode || !_M_has_sol)
      40*:  215:	    _M_dfs(__match_mode, __state._M_next);
        -:  216:	}
        -:  217:      else // Non-greedy mode
        -:  218:	{
        -:  219:	  if (__dfs_mode)
        -:  220:	    {
        -:  221:	      // vice-versa.
    #####:  222:	      _M_dfs(__match_mode, __state._M_next);
    #####:  223:	      if (!_M_has_sol)
    #####:  224:		_M_rep_once_more(__match_mode, __i);
        -:  225:	    }
        -:  226:	  else
        -:  227:	    {
        -:  228:	      // DON'T attempt anything, because there's already another
        -:  229:	      // state with higher priority accepted. This state cannot
        -:  230:	      // be better by attempting its next node.
    #####:  231:	      if (!_M_has_sol)
        -:  232:		{
    #####:  233:		  _M_dfs(__match_mode, __state._M_next);
        -:  234:		  // DON'T attempt anything if it's already accepted. An
        -:  235:		  // accepted state *must* be better than a solution that
        -:  236:		  // matches a non-greedy quantifier one more time.
    #####:  237:		  if (!_M_has_sol)
    #####:  238:		    _M_rep_once_more(__match_mode, __i);
        -:  239:		}
        -:  240:	    }
        -:  241:	}
      52*:  242:    }
------------------
_ZNSt8__detail9_ExecutorIPKcSaINSt7__cxx119sub_matchIS2_EEENS3_12regex_traitsIcEELb1EE16_M_handle_repeatENS9_11_Match_modeEl:
       52:  204:    void _Executor<_BiIter, _Alloc, _TraitsT, __dfs_mode>::
        -:  205:    _M_handle_repeat(_Match_mode __match_mode, _StateIdT __i)
        -:  206:    {
       52:  207:      const auto& __state = _M_nfa[__i];
       52:  207-block  0
        -:  208:
        -:  209:      // Greedy.
       52:  210:      if (!__state._M_neg)
        -:  211:	{
       52:  212:	  _M_rep_once_more(__match_mode, __i);
       52:  212-block  0
        -:  213:	  // If it's DFS executor and already accepted, we're done.
       52:  214:	  if (!__dfs_mode || !_M_has_sol)
       40:  215:	    _M_dfs(__match_mode, __state._M_next);
       40:  215-block  0
        -:  216:	}
        -:  217:      else // Non-greedy mode
        -:  218:	{
        -:  219:	  if (__dfs_mode)
        -:  220:	    {
        -:  221:	      // vice-versa.
    #####:  222:	      _M_dfs(__match_mode, __state._M_next);
    %%%%%:  222-block  0
    #####:  223:	      if (!_M_has_sol)
    #####:  224:		_M_rep_once_more(__match_mode, __i);
    %%%%%:  224-block  0
        -:  225:	    }
        -:  226:	  else
        -:  227:	    {
        -:  228:	      // DON'T attempt anything, because there's already another
        -:  229:	      // state with higher priority accepted. This state cannot
        -:  230:	      // be better by attempting its next node.
        -:  231:	      if (!_M_has_sol)
        -:  232:		{
        -:  233:		  _M_dfs(__match_mode, __state._M_next);
        -:  234:		  // DON'T attempt anything if it's already accepted. An
        -:  235:		  // accepted state *must* be better than a solution that
        -:  236:		  // matches a non-greedy quantifier one more time.
        -:  237:		  if (!_M_has_sol)
        -:  238:		    _M_rep_once_more(__match_mode, __i);
        -:  239:		}
        -:  240:	    }
        -:  241:	}
       52:  242:    }
------------------
_ZNSt8__detail9_ExecutorIPKcSaINSt7__cxx119sub_matchIS2_EEENS3_12regex_traitsIcEELb0EE16_M_handle_repeatENS9_11_Match_modeEl:
    #####:  204:    void _Executor<_BiIter, _Alloc, _TraitsT, __dfs_mode>::
        -:  205:    _M_handle_repeat(_Match_mode __match_mode, _StateIdT __i)
        -:  206:    {
    #####:  207:      const auto& __state = _M_nfa[__i];
    %%%%%:  207-block  0
        -:  208:
        -:  209:      // Greedy.
    #####:  210:      if (!__state._M_neg)
        -:  211:	{
    #####:  212:	  _M_rep_once_more(__match_mode, __i);
    %%%%%:  212-block  0
        -:  213:	  // If it's DFS executor and already accepted, we're done.
        -:  214:	  if (!__dfs_mode || !_M_has_sol)
    #####:  215:	    _M_dfs(__match_mode, __state._M_next);
        -:  216:	}
        -:  217:      else // Non-greedy mode
        -:  218:	{
        -:  219:	  if (__dfs_mode)
        -:  220:	    {
        -:  221:	      // vice-versa.
        -:  222:	      _M_dfs(__match_mode, __state._M_next);
        -:  223:	      if (!_M_has_sol)
        -:  224:		_M_rep_once_more(__match_mode, __i);
        -:  225:	    }
        -:  226:	  else
        -:  227:	    {
        -:  228:	      // DON'T attempt anything, because there's already another
        -:  229:	      // state with higher priority accepted. This state cannot
        -:  230:	      // be better by attempting its next node.
    #####:  231:	      if (!_M_has_sol)
    %%%%%:  231-block  0
        -:  232:		{
    #####:  233:		  _M_dfs(__match_mode, __state._M_next);
    %%%%%:  233-block  0
        -:  234:		  // DON'T attempt anything if it's already accepted. An
        -:  235:		  // accepted state *must* be better than a solution that
        -:  236:		  // matches a non-greedy quantifier one more time.
    #####:  237:		  if (!_M_has_sol)
    #####:  238:		    _M_rep_once_more(__match_mode, __i);
    %%%%%:  238-block  0
        -:  239:		}
        -:  240:	    }
        -:  241:	}
    #####:  242:    }
------------------
        -:  243:
        -:  244:  template<typename _BiIter, typename _Alloc, typename _TraitsT,
        -:  245:	   bool __dfs_mode>
      29*:  246:    void _Executor<_BiIter, _Alloc, _TraitsT, __dfs_mode>::
        -:  247:    _M_handle_subexpr_begin(_Match_mode __match_mode, _StateIdT __i)
        -:  248:    {
      29*:  249:      const auto& __state = _M_nfa[__i];
        -:  250:
      29*:  251:      auto& __res = _M_cur_results[__state._M_subexpr];
      29*:  252:      auto __back = __res.first;
      29*:  253:      __res.first = _M_current;
      29*:  254:      _M_dfs(__match_mode, __state._M_next);
      29*:  255:      __res.first = __back;
      29*:  256:    }
------------------
_ZNSt8__detail9_ExecutorIPKcSaINSt7__cxx119sub_matchIS2_EEENS3_12regex_traitsIcEELb1EE23_M_handle_subexpr_beginENS9_11_Match_modeEl:
       29:  246:    void _Executor<_BiIter, _Alloc, _TraitsT, __dfs_mode>::
        -:  247:    _M_handle_subexpr_begin(_Match_mode __match_mode, _StateIdT __i)
        -:  248:    {
       29:  249:      const auto& __state = _M_nfa[__i];
       29:  249-block  0
        -:  250:
       29:  251:      auto& __res = _M_cur_results[__state._M_subexpr];
       29:  252:      auto __back = __res.first;
       29:  253:      __res.first = _M_current;
       29:  254:      _M_dfs(__match_mode, __state._M_next);
       29:  255:      __res.first = __back;
       29:  256:    }
------------------
_ZNSt8__detail9_ExecutorIPKcSaINSt7__cxx119sub_matchIS2_EEENS3_12regex_traitsIcEELb0EE23_M_handle_subexpr_beginENS9_11_Match_modeEl:
    #####:  246:    void _Executor<_BiIter, _Alloc, _TraitsT, __dfs_mode>::
        -:  247:    _M_handle_subexpr_begin(_Match_mode __match_mode, _StateIdT __i)
        -:  248:    {
    #####:  249:      const auto& __state = _M_nfa[__i];
    %%%%%:  249-block  0
        -:  250:
    #####:  251:      auto& __res = _M_cur_results[__state._M_subexpr];
    #####:  252:      auto __back = __res.first;
    #####:  253:      __res.first = _M_current;
    #####:  254:      _M_dfs(__match_mode, __state._M_next);
    #####:  255:      __res.first = __back;
    #####:  256:    }
------------------
        -:  257:
        -:  258:  template<typename _BiIter, typename _Alloc, typename _TraitsT,
        -:  259:	   bool __dfs_mode>
      24*:  260:    void _Executor<_BiIter, _Alloc, _TraitsT, __dfs_mode>::
        -:  261:    _M_handle_subexpr_end(_Match_mode __match_mode, _StateIdT __i)
        -:  262:    {
      24*:  263:      const auto& __state = _M_nfa[__i];
        -:  264:
      24*:  265:      auto& __res = _M_cur_results[__state._M_subexpr];
      24*:  266:      auto __back = __res;
      24*:  267:      __res.second = _M_current;
      24*:  268:      __res.matched = true;
      24*:  269:      _M_dfs(__match_mode, __state._M_next);
      24*:  270:      __res = __back;
      24*:  271:    }
------------------
_ZNSt8__detail9_ExecutorIPKcSaINSt7__cxx119sub_matchIS2_EEENS3_12regex_traitsIcEELb1EE21_M_handle_subexpr_endENS9_11_Match_modeEl:
       24:  260:    void _Executor<_BiIter, _Alloc, _TraitsT, __dfs_mode>::
        -:  261:    _M_handle_subexpr_end(_Match_mode __match_mode, _StateIdT __i)
        -:  262:    {
       24:  263:      const auto& __state = _M_nfa[__i];
       24:  263-block  0
        -:  264:
       24:  265:      auto& __res = _M_cur_results[__state._M_subexpr];
       24:  266:      auto __back = __res;
       24:  267:      __res.second = _M_current;
       24:  268:      __res.matched = true;
       24:  269:      _M_dfs(__match_mode, __state._M_next);
       24:  270:      __res = __back;
       24:  270-block  0
       24:  271:    }
       24:  271-block  0
------------------
_ZNSt8__detail9_ExecutorIPKcSaINSt7__cxx119sub_matchIS2_EEENS3_12regex_traitsIcEELb0EE21_M_handle_subexpr_endENS9_11_Match_modeEl:
    #####:  260:    void _Executor<_BiIter, _Alloc, _TraitsT, __dfs_mode>::
        -:  261:    _M_handle_subexpr_end(_Match_mode __match_mode, _StateIdT __i)
        -:  262:    {
    #####:  263:      const auto& __state = _M_nfa[__i];
    %%%%%:  263-block  0
        -:  264:
    #####:  265:      auto& __res = _M_cur_results[__state._M_subexpr];
    #####:  266:      auto __back = __res;
    #####:  267:      __res.second = _M_current;
    #####:  268:      __res.matched = true;
    #####:  269:      _M_dfs(__match_mode, __state._M_next);
    #####:  270:      __res = __back;
    %%%%%:  270-block  0
    #####:  271:    }
    %%%%%:  271-block  0
------------------
        -:  272:
        -:  273:  template<typename _BiIter, typename _Alloc, typename _TraitsT,
        -:  274:	   bool __dfs_mode>
    #####:  275:    inline void _Executor<_BiIter, _Alloc, _TraitsT, __dfs_mode>::
        -:  276:    _M_handle_line_begin_assertion(_Match_mode __match_mode, _StateIdT __i)
        -:  277:    {
    #####:  278:      const auto& __state = _M_nfa[__i];
    #####:  279:      if (_M_at_begin())
    #####:  280:	_M_dfs(__match_mode, __state._M_next);
    #####:  281:    }
------------------
_ZNSt8__detail9_ExecutorIPKcSaINSt7__cxx119sub_matchIS2_EEENS3_12regex_traitsIcEELb1EE30_M_handle_line_begin_assertionENS9_11_Match_modeEl:
    #####:  275:    inline void _Executor<_BiIter, _Alloc, _TraitsT, __dfs_mode>::
        -:  276:    _M_handle_line_begin_assertion(_Match_mode __match_mode, _StateIdT __i)
        -:  277:    {
    #####:  278:      const auto& __state = _M_nfa[__i];
    %%%%%:  278-block  0
    #####:  279:      if (_M_at_begin())
    #####:  280:	_M_dfs(__match_mode, __state._M_next);
    %%%%%:  280-block  0
    #####:  281:    }
------------------
_ZNSt8__detail9_ExecutorIPKcSaINSt7__cxx119sub_matchIS2_EEENS3_12regex_traitsIcEELb0EE30_M_handle_line_begin_assertionENS9_11_Match_modeEl:
    #####:  275:    inline void _Executor<_BiIter, _Alloc, _TraitsT, __dfs_mode>::
        -:  276:    _M_handle_line_begin_assertion(_Match_mode __match_mode, _StateIdT __i)
        -:  277:    {
    #####:  278:      const auto& __state = _M_nfa[__i];
    %%%%%:  278-block  0
    #####:  279:      if (_M_at_begin())
    #####:  280:	_M_dfs(__match_mode, __state._M_next);
    %%%%%:  280-block  0
    #####:  281:    }
------------------
        -:  282:
        -:  283:  template<typename _BiIter, typename _Alloc, typename _TraitsT,
        -:  284:	   bool __dfs_mode>
    #####:  285:    inline void _Executor<_BiIter, _Alloc, _TraitsT, __dfs_mode>::
        -:  286:    _M_handle_line_end_assertion(_Match_mode __match_mode, _StateIdT __i)
        -:  287:    {
    #####:  288:      const auto& __state = _M_nfa[__i];
    #####:  289:      if (_M_at_end())
    #####:  290:	_M_dfs(__match_mode, __state._M_next);
    #####:  291:    }
------------------
_ZNSt8__detail9_ExecutorIPKcSaINSt7__cxx119sub_matchIS2_EEENS3_12regex_traitsIcEELb1EE28_M_handle_line_end_assertionENS9_11_Match_modeEl:
    #####:  285:    inline void _Executor<_BiIter, _Alloc, _TraitsT, __dfs_mode>::
        -:  286:    _M_handle_line_end_assertion(_Match_mode __match_mode, _StateIdT __i)
        -:  287:    {
    #####:  288:      const auto& __state = _M_nfa[__i];
    %%%%%:  288-block  0
    #####:  289:      if (_M_at_end())
    #####:  290:	_M_dfs(__match_mode, __state._M_next);
    %%%%%:  290-block  0
    #####:  291:    }
------------------
_ZNSt8__detail9_ExecutorIPKcSaINSt7__cxx119sub_matchIS2_EEENS3_12regex_traitsIcEELb0EE28_M_handle_line_end_assertionENS9_11_Match_modeEl:
    #####:  285:    inline void _Executor<_BiIter, _Alloc, _TraitsT, __dfs_mode>::
        -:  286:    _M_handle_line_end_assertion(_Match_mode __match_mode, _StateIdT __i)
        -:  287:    {
    #####:  288:      const auto& __state = _M_nfa[__i];
    %%%%%:  288-block  0
    #####:  289:      if (_M_at_end())
    #####:  290:	_M_dfs(__match_mode, __state._M_next);
    %%%%%:  290-block  0
    #####:  291:    }
------------------
        -:  292:
        -:  293:  template<typename _BiIter, typename _Alloc, typename _TraitsT,
        -:  294:	   bool __dfs_mode>
    #####:  295:    inline void _Executor<_BiIter, _Alloc, _TraitsT, __dfs_mode>::
        -:  296:    _M_handle_word_boundary(_Match_mode __match_mode, _StateIdT __i)
        -:  297:    {
    #####:  298:      const auto& __state = _M_nfa[__i];
    #####:  299:      if (_M_word_boundary() == !__state._M_neg)
    #####:  300:	_M_dfs(__match_mode, __state._M_next);
    #####:  301:    }
------------------
_ZNSt8__detail9_ExecutorIPKcSaINSt7__cxx119sub_matchIS2_EEENS3_12regex_traitsIcEELb1EE23_M_handle_word_boundaryENS9_11_Match_modeEl:
    #####:  295:    inline void _Executor<_BiIter, _Alloc, _TraitsT, __dfs_mode>::
        -:  296:    _M_handle_word_boundary(_Match_mode __match_mode, _StateIdT __i)
        -:  297:    {
    #####:  298:      const auto& __state = _M_nfa[__i];
    %%%%%:  298-block  0
    #####:  299:      if (_M_word_boundary() == !__state._M_neg)
    #####:  300:	_M_dfs(__match_mode, __state._M_next);
    %%%%%:  300-block  0
    #####:  301:    }
------------------
_ZNSt8__detail9_ExecutorIPKcSaINSt7__cxx119sub_matchIS2_EEENS3_12regex_traitsIcEELb0EE23_M_handle_word_boundaryENS9_11_Match_modeEl:
    #####:  295:    inline void _Executor<_BiIter, _Alloc, _TraitsT, __dfs_mode>::
        -:  296:    _M_handle_word_boundary(_Match_mode __match_mode, _StateIdT __i)
        -:  297:    {
    #####:  298:      const auto& __state = _M_nfa[__i];
    %%%%%:  298-block  0
    #####:  299:      if (_M_word_boundary() == !__state._M_neg)
    #####:  300:	_M_dfs(__match_mode, __state._M_next);
    %%%%%:  300-block  0
    #####:  301:    }
------------------
        -:  302:
        -:  303:  // Here __state._M_alt offers a single start node for a sub-NFA.
        -:  304:  // We recursively invoke our algorithm to match the sub-NFA.
        -:  305:  template<typename _BiIter, typename _Alloc, typename _TraitsT,
        -:  306:	   bool __dfs_mode>
    #####:  307:    void _Executor<_BiIter, _Alloc, _TraitsT, __dfs_mode>::
        -:  308:    _M_handle_subexpr_lookahead(_Match_mode __match_mode, _StateIdT __i)
        -:  309:    {
    #####:  310:      const auto& __state = _M_nfa[__i];
    #####:  311:      if (_M_lookahead(__state._M_alt) == !__state._M_neg)
    #####:  312:	_M_dfs(__match_mode, __state._M_next);
    #####:  313:    }
------------------
_ZNSt8__detail9_ExecutorIPKcSaINSt7__cxx119sub_matchIS2_EEENS3_12regex_traitsIcEELb1EE27_M_handle_subexpr_lookaheadENS9_11_Match_modeEl:
    #####:  307:    void _Executor<_BiIter, _Alloc, _TraitsT, __dfs_mode>::
        -:  308:    _M_handle_subexpr_lookahead(_Match_mode __match_mode, _StateIdT __i)
        -:  309:    {
    #####:  310:      const auto& __state = _M_nfa[__i];
    %%%%%:  310-block  0
    #####:  311:      if (_M_lookahead(__state._M_alt) == !__state._M_neg)
    #####:  312:	_M_dfs(__match_mode, __state._M_next);
    %%%%%:  312-block  0
    #####:  313:    }
------------------
_ZNSt8__detail9_ExecutorIPKcSaINSt7__cxx119sub_matchIS2_EEENS3_12regex_traitsIcEELb0EE27_M_handle_subexpr_lookaheadENS9_11_Match_modeEl:
    #####:  307:    void _Executor<_BiIter, _Alloc, _TraitsT, __dfs_mode>::
        -:  308:    _M_handle_subexpr_lookahead(_Match_mode __match_mode, _StateIdT __i)
        -:  309:    {
    #####:  310:      const auto& __state = _M_nfa[__i];
    %%%%%:  310-block  0
    #####:  311:      if (_M_lookahead(__state._M_alt) == !__state._M_neg)
    #####:  312:	_M_dfs(__match_mode, __state._M_next);
    %%%%%:  312-block  0
    #####:  313:    }
------------------
        -:  314:
        -:  315:  template<typename _BiIter, typename _Alloc, typename _TraitsT,
        -:  316:	   bool __dfs_mode>
      73*:  317:    void _Executor<_BiIter, _Alloc, _TraitsT, __dfs_mode>::
        -:  318:    _M_handle_match(_Match_mode __match_mode, _StateIdT __i)
        -:  319:    {
      73*:  320:      const auto& __state = _M_nfa[__i];
        -:  321:
      73*:  322:      if (_M_current == _M_end)
       6*:  323:	return;
        -:  324:      if (__dfs_mode)
        -:  325:	{
       67:  326:	  if (__state._M_matches(*_M_current))
        -:  327:	    {
       33:  328:	      ++_M_current;
       33:  329:	      _M_dfs(__match_mode, __state._M_next);
       33:  330:	      --_M_current;
        -:  331:	    }
        -:  332:	}
        -:  333:      else
    #####:  334:	if (__state._M_matches(*_M_current))
    #####:  335:	  _M_states._M_queue(__state._M_next, _M_cur_results);
        -:  336:    }
------------------
_ZNSt8__detail9_ExecutorIPKcSaINSt7__cxx119sub_matchIS2_EEENS3_12regex_traitsIcEELb1EE15_M_handle_matchENS9_11_Match_modeEl:
       73:  317:    void _Executor<_BiIter, _Alloc, _TraitsT, __dfs_mode>::
        -:  318:    _M_handle_match(_Match_mode __match_mode, _StateIdT __i)
        -:  319:    {
       73:  320:      const auto& __state = _M_nfa[__i];
       73:  320-block  0
        -:  321:
       73:  322:      if (_M_current == _M_end)
        6:  323:	return;
        6:  323-block  0
        -:  324:      if (__dfs_mode)
        -:  325:	{
       67:  326:	  if (__state._M_matches(*_M_current))
       67:  326-block  0
        -:  327:	    {
       33:  328:	      ++_M_current;
       33:  329:	      _M_dfs(__match_mode, __state._M_next);
       33:  329-block  0
       33:  330:	      --_M_current;
        -:  331:	    }
        -:  332:	}
        -:  333:      else
        -:  334:	if (__state._M_matches(*_M_current))
        -:  335:	  _M_states._M_queue(__state._M_next, _M_cur_results);
        -:  336:    }
------------------
_ZNSt8__detail9_ExecutorIPKcSaINSt7__cxx119sub_matchIS2_EEENS3_12regex_traitsIcEELb0EE15_M_handle_matchENS9_11_Match_modeEl:
    #####:  317:    void _Executor<_BiIter, _Alloc, _TraitsT, __dfs_mode>::
        -:  318:    _M_handle_match(_Match_mode __match_mode, _StateIdT __i)
        -:  319:    {
    #####:  320:      const auto& __state = _M_nfa[__i];
    %%%%%:  320-block  0
        -:  321:
    #####:  322:      if (_M_current == _M_end)
    #####:  323:	return;
    %%%%%:  323-block  0
        -:  324:      if (__dfs_mode)
        -:  325:	{
        -:  326:	  if (__state._M_matches(*_M_current))
        -:  327:	    {
        -:  328:	      ++_M_current;
        -:  329:	      _M_dfs(__match_mode, __state._M_next);
        -:  330:	      --_M_current;
        -:  331:	    }
        -:  332:	}
        -:  333:      else
    #####:  334:	if (__state._M_matches(*_M_current))
    %%%%%:  334-block  0
    #####:  335:	  _M_states._M_queue(__state._M_next, _M_cur_results);
    %%%%%:  335-block  0
        -:  336:    }
------------------
        -:  337:
        -:  338:  template<typename _BiIter, typename _TraitsT>
        -:  339:    struct _Backref_matcher
        -:  340:    {
        -:  341:      _Backref_matcher(bool __icase, const _TraitsT& __traits)
        -:  342:      : _M_traits(__traits) { }
        -:  343:
        -:  344:      bool
        -:  345:      _M_apply(_BiIter __expected_begin,
        -:  346:	       _BiIter __expected_end, _BiIter __actual_begin,
        -:  347:	       _BiIter __actual_end)
        -:  348:      {
        -:  349:	return _M_traits.transform(__expected_begin, __expected_end)
        -:  350:	    == _M_traits.transform(__actual_begin, __actual_end);
        -:  351:      }
        -:  352:
        -:  353:      const _TraitsT& _M_traits;
        -:  354:    };
        -:  355:
        -:  356:  template<typename _BiIter, typename _CharT>
        -:  357:    struct _Backref_matcher<_BiIter, std::regex_traits<_CharT>>
        -:  358:    {
        -:  359:      using _TraitsT = std::regex_traits<_CharT>;
    #####:  360:      _Backref_matcher(bool __icase, const _TraitsT& __traits)
    #####:  361:      : _M_icase(__icase), _M_traits(__traits) { }
        -:  362:
        -:  363:      bool
    #####:  364:      _M_apply(_BiIter __expected_begin,
        -:  365:	       _BiIter __expected_end, _BiIter __actual_begin,
        -:  366:	       _BiIter __actual_end)
        -:  367:      {
    #####:  368:	if (!_M_icase)
    %%%%%:  368-block  0
    #####:  369:	  return _GLIBCXX_STD_A::__equal4(__expected_begin, __expected_end,
    %%%%%:  369-block  0
    #####:  370:			       __actual_begin, __actual_end);
        -:  371:	typedef std::ctype<_CharT> __ctype_type;
    #####:  372:	const auto& __fctyp = use_facet<__ctype_type>(_M_traits.getloc());
    %%%%%:  372-block  0
    %%%%%:  372-block  1
    $$$$$:  372-block  2
    #####:  373:	return _GLIBCXX_STD_A::__equal4(__expected_begin, __expected_end,
        -:  374:			     __actual_begin, __actual_end,
    #####:  375:			     [this, &__fctyp](_CharT __lhs, _CharT __rhs)
        -:  376:			     {
        -:  377:			       return __fctyp.tolower(__lhs)
    #####:  378:				 == __fctyp.tolower(__rhs);
    %%%%%:  378-block  0
    #####:  379:			     });
        -:  380:      }
        -:  381:
        -:  382:      bool _M_icase;
        -:  383:      const _TraitsT& _M_traits;
        -:  384:    };
        -:  385:
        -:  386:  // First fetch the matched result from _M_cur_results as __submatch;
        -:  387:  // then compare it with
        -:  388:  // (_M_current, _M_current + (__submatch.second - __submatch.first)).
        -:  389:  // If matched, keep going; else just return and try another state.
        -:  390:  template<typename _BiIter, typename _Alloc, typename _TraitsT,
        -:  391:	   bool __dfs_mode>
    #####:  392:    void _Executor<_BiIter, _Alloc, _TraitsT, __dfs_mode>::
        -:  393:    _M_handle_backref(_Match_mode __match_mode, _StateIdT __i)
        -:  394:    {
        -:  395:      __glibcxx_assert(__dfs_mode);
        -:  396:
    #####:  397:      const auto& __state = _M_nfa[__i];
    #####:  398:      auto& __submatch = _M_cur_results[__state._M_backref_index];
    #####:  399:      if (!__submatch.matched)
    #####:  400:	return;
    #####:  401:      auto __last = _M_current;
    #####:  402:      for (auto __tmp = __submatch.first;
    #####:  403:	   __last != _M_end && __tmp != __submatch.second;
        -:  404:	   ++__tmp)
    #####:  405:	++__last;
    #####:  406:      if (_Backref_matcher<_BiIter, _TraitsT>(
    #####:  407:	      _M_re.flags() & regex_constants::icase,
    #####:  408:	      _M_re._M_automaton->_M_traits)._M_apply(
        -:  409:		  __submatch.first, __submatch.second, _M_current, __last))
        -:  410:	{
    #####:  411:	  if (__last != _M_current)
        -:  412:	    {
    #####:  413:	      auto __backup = _M_current;
    #####:  414:	      _M_current = __last;
    #####:  415:	      _M_dfs(__match_mode, __state._M_next);
    #####:  416:	      _M_current = __backup;
        -:  417:	    }
        -:  418:	  else
    #####:  419:	    _M_dfs(__match_mode, __state._M_next);
        -:  420:	}
        -:  421:    }
------------------
_ZNSt8__detail9_ExecutorIPKcSaINSt7__cxx119sub_matchIS2_EEENS3_12regex_traitsIcEELb1EE17_M_handle_backrefENS9_11_Match_modeEl:
    #####:  392:    void _Executor<_BiIter, _Alloc, _TraitsT, __dfs_mode>::
        -:  393:    _M_handle_backref(_Match_mode __match_mode, _StateIdT __i)
        -:  394:    {
        -:  395:      __glibcxx_assert(__dfs_mode);
        -:  396:
    #####:  397:      const auto& __state = _M_nfa[__i];
    %%%%%:  397-block  0
    #####:  398:      auto& __submatch = _M_cur_results[__state._M_backref_index];
    #####:  399:      if (!__submatch.matched)
    #####:  400:	return;
    %%%%%:  400-block  0
    #####:  401:      auto __last = _M_current;
    #####:  402:      for (auto __tmp = __submatch.first;
    %%%%%:  402-block  0
    #####:  403:	   __last != _M_end && __tmp != __submatch.second;
    %%%%%:  403-block  0
    %%%%%:  403-block  1
        -:  404:	   ++__tmp)
    #####:  405:	++__last;
    %%%%%:  405-block  0
    #####:  406:      if (_Backref_matcher<_BiIter, _TraitsT>(
    %%%%%:  406-block  0
    #####:  407:	      _M_re.flags() & regex_constants::icase,
    #####:  408:	      _M_re._M_automaton->_M_traits)._M_apply(
    %%%%%:  408-block  0
        -:  409:		  __submatch.first, __submatch.second, _M_current, __last))
        -:  410:	{
    #####:  411:	  if (__last != _M_current)
    %%%%%:  411-block  0
        -:  412:	    {
    #####:  413:	      auto __backup = _M_current;
    #####:  414:	      _M_current = __last;
    #####:  415:	      _M_dfs(__match_mode, __state._M_next);
    %%%%%:  415-block  0
    #####:  416:	      _M_current = __backup;
        -:  417:	    }
        -:  418:	  else
    #####:  419:	    _M_dfs(__match_mode, __state._M_next);
    %%%%%:  419-block  0
        -:  420:	}
        -:  421:    }
------------------
_ZNSt8__detail9_ExecutorIPKcSaINSt7__cxx119sub_matchIS2_EEENS3_12regex_traitsIcEELb0EE17_M_handle_backrefENS9_11_Match_modeEl:
    #####:  392:    void _Executor<_BiIter, _Alloc, _TraitsT, __dfs_mode>::
        -:  393:    _M_handle_backref(_Match_mode __match_mode, _StateIdT __i)
        -:  394:    {
        -:  395:      __glibcxx_assert(__dfs_mode);
        -:  396:
    #####:  397:      const auto& __state = _M_nfa[__i];
    %%%%%:  397-block  0
    #####:  398:      auto& __submatch = _M_cur_results[__state._M_backref_index];
    #####:  399:      if (!__submatch.matched)
    #####:  400:	return;
    %%%%%:  400-block  0
    #####:  401:      auto __last = _M_current;
    #####:  402:      for (auto __tmp = __submatch.first;
    %%%%%:  402-block  0
    #####:  403:	   __last != _M_end && __tmp != __submatch.second;
    %%%%%:  403-block  0
    %%%%%:  403-block  1
        -:  404:	   ++__tmp)
    #####:  405:	++__last;
    %%%%%:  405-block  0
    #####:  406:      if (_Backref_matcher<_BiIter, _TraitsT>(
    %%%%%:  406-block  0
    #####:  407:	      _M_re.flags() & regex_constants::icase,
    #####:  408:	      _M_re._M_automaton->_M_traits)._M_apply(
    %%%%%:  408-block  0
        -:  409:		  __submatch.first, __submatch.second, _M_current, __last))
        -:  410:	{
    #####:  411:	  if (__last != _M_current)
    %%%%%:  411-block  0
        -:  412:	    {
    #####:  413:	      auto __backup = _M_current;
    #####:  414:	      _M_current = __last;
    #####:  415:	      _M_dfs(__match_mode, __state._M_next);
    %%%%%:  415-block  0
    #####:  416:	      _M_current = __backup;
        -:  417:	    }
        -:  418:	  else
    #####:  419:	    _M_dfs(__match_mode, __state._M_next);
    %%%%%:  419-block  0
        -:  420:	}
        -:  421:    }
------------------
        -:  422:
        -:  423:  template<typename _BiIter, typename _Alloc, typename _TraitsT,
        -:  424:	   bool __dfs_mode>
       3*:  425:    void _Executor<_BiIter, _Alloc, _TraitsT, __dfs_mode>::
        -:  426:    _M_handle_accept(_Match_mode __match_mode, _StateIdT __i)
        -:  427:    {
        -:  428:      if (__dfs_mode)
        -:  429:	{
        -:  430:	  __glibcxx_assert(!_M_has_sol);
        3:  431:	  if (__match_mode == _Match_mode::_Exact)
    #####:  432:	    _M_has_sol = _M_current == _M_end;
        -:  433:	  else
        3:  434:	    _M_has_sol = true;
        6:  435:	  if (_M_current == _M_begin
       3*:  436:	      && (_M_flags & regex_constants::match_not_null))
    #####:  437:	    _M_has_sol = false;
        3:  438:	  if (_M_has_sol)
        -:  439:	    {
        3:  440:	      if (_M_nfa._M_flags & regex_constants::ECMAScript)
        3:  441:		_M_results = _M_cur_results;
        -:  442:	      else // POSIX
        -:  443:		{
        -:  444:		  __glibcxx_assert(_M_states._M_get_sol_pos());
        -:  445:		  // Here's POSIX's logic: match the longest one. However
        -:  446:		  // we never know which one (lhs or rhs of "|") is longer
        -:  447:		  // unless we try both of them and compare the results.
        -:  448:		  // The member variable _M_sol_pos records the end
        -:  449:		  // position of the last successful match. It's better
        -:  450:		  // to be larger, because POSIX regex is always greedy.
        -:  451:		  // TODO: This could be slow.
    #####:  452:		  if (*_M_states._M_get_sol_pos() == _BiIter()
    #####:  453:		      || std::distance(_M_begin,
    #####:  454:				       *_M_states._M_get_sol_pos())
    #####:  455:			 < std::distance(_M_begin, _M_current))
        -:  456:		    {
    #####:  457:		      *_M_states._M_get_sol_pos() = _M_current;
    #####:  458:		      _M_results = _M_cur_results;
        -:  459:		    }
        -:  460:		}
        -:  461:	    }
        -:  462:	}
        -:  463:      else
        -:  464:	{
    #####:  465:	  if (_M_current == _M_begin
    #####:  466:	      && (_M_flags & regex_constants::match_not_null))
    #####:  467:	    return;
    #####:  468:	  if (__match_mode == _Match_mode::_Prefix || _M_current == _M_end)
    #####:  469:	    if (!_M_has_sol)
        -:  470:	      {
    #####:  471:		_M_has_sol = true;
    #####:  472:		_M_results = _M_cur_results;
        -:  473:	      }
        -:  474:	}
        -:  475:    }
------------------
_ZNSt8__detail9_ExecutorIPKcSaINSt7__cxx119sub_matchIS2_EEENS3_12regex_traitsIcEELb1EE16_M_handle_acceptENS9_11_Match_modeEl:
        3:  425:    void _Executor<_BiIter, _Alloc, _TraitsT, __dfs_mode>::
        3:  425-block  0
        -:  426:    _M_handle_accept(_Match_mode __match_mode, _StateIdT __i)
        -:  427:    {
        -:  428:      if (__dfs_mode)
        -:  429:	{
        -:  430:	  __glibcxx_assert(!_M_has_sol);
        3:  431:	  if (__match_mode == _Match_mode::_Exact)
        3:  431-block  0
    #####:  432:	    _M_has_sol = _M_current == _M_end;
    %%%%%:  432-block  0
        -:  433:	  else
        3:  434:	    _M_has_sol = true;
        3:  434-block  0
        6:  435:	  if (_M_current == _M_begin
       3*:  436:	      && (_M_flags & regex_constants::match_not_null))
        3:  436-block  0
    %%%%%:  436-block  1
    %%%%%:  436-block  2
        3:  436-block  3
        3:  436-block  4
    #####:  437:	    _M_has_sol = false;
    %%%%%:  437-block  0
        3:  438:	  if (_M_has_sol)
        3:  438-block  0
        -:  439:	    {
        3:  440:	      if (_M_nfa._M_flags & regex_constants::ECMAScript)
        3:  440-block  0
        3:  441:		_M_results = _M_cur_results;
        3:  441-block  0
        -:  442:	      else // POSIX
        -:  443:		{
        -:  444:		  __glibcxx_assert(_M_states._M_get_sol_pos());
        -:  445:		  // Here's POSIX's logic: match the longest one. However
        -:  446:		  // we never know which one (lhs or rhs of "|") is longer
        -:  447:		  // unless we try both of them and compare the results.
        -:  448:		  // The member variable _M_sol_pos records the end
        -:  449:		  // position of the last successful match. It's better
        -:  450:		  // to be larger, because POSIX regex is always greedy.
        -:  451:		  // TODO: This could be slow.
    #####:  452:		  if (*_M_states._M_get_sol_pos() == _BiIter()
    %%%%%:  452-block  0
    #####:  453:		      || std::distance(_M_begin,
    %%%%%:  453-block  0
    %%%%%:  453-block  1
    %%%%%:  453-block  2
    #####:  454:				       *_M_states._M_get_sol_pos())
    %%%%%:  454-block  0
    #####:  455:			 < std::distance(_M_begin, _M_current))
        -:  456:		    {
    #####:  457:		      *_M_states._M_get_sol_pos() = _M_current;
    %%%%%:  457-block  0
    #####:  458:		      _M_results = _M_cur_results;
        -:  459:		    }
        -:  460:		}
        -:  461:	    }
        -:  462:	}
        -:  463:      else
        -:  464:	{
        -:  465:	  if (_M_current == _M_begin
        -:  466:	      && (_M_flags & regex_constants::match_not_null))
        -:  467:	    return;
        -:  468:	  if (__match_mode == _Match_mode::_Prefix || _M_current == _M_end)
        -:  469:	    if (!_M_has_sol)
        -:  470:	      {
        -:  471:		_M_has_sol = true;
        -:  472:		_M_results = _M_cur_results;
        -:  473:	      }
        -:  474:	}
        -:  475:    }
------------------
_ZNSt8__detail9_ExecutorIPKcSaINSt7__cxx119sub_matchIS2_EEENS3_12regex_traitsIcEELb0EE16_M_handle_acceptENS9_11_Match_modeEl:
    #####:  425:    void _Executor<_BiIter, _Alloc, _TraitsT, __dfs_mode>::
    %%%%%:  425-block  0
        -:  426:    _M_handle_accept(_Match_mode __match_mode, _StateIdT __i)
        -:  427:    {
        -:  428:      if (__dfs_mode)
        -:  429:	{
        -:  430:	  __glibcxx_assert(!_M_has_sol);
        -:  431:	  if (__match_mode == _Match_mode::_Exact)
        -:  432:	    _M_has_sol = _M_current == _M_end;
        -:  433:	  else
        -:  434:	    _M_has_sol = true;
        -:  435:	  if (_M_current == _M_begin
        -:  436:	      && (_M_flags & regex_constants::match_not_null))
        -:  437:	    _M_has_sol = false;
        -:  438:	  if (_M_has_sol)
        -:  439:	    {
        -:  440:	      if (_M_nfa._M_flags & regex_constants::ECMAScript)
        -:  441:		_M_results = _M_cur_results;
        -:  442:	      else // POSIX
        -:  443:		{
        -:  444:		  __glibcxx_assert(_M_states._M_get_sol_pos());
        -:  445:		  // Here's POSIX's logic: match the longest one. However
        -:  446:		  // we never know which one (lhs or rhs of "|") is longer
        -:  447:		  // unless we try both of them and compare the results.
        -:  448:		  // The member variable _M_sol_pos records the end
        -:  449:		  // position of the last successful match. It's better
        -:  450:		  // to be larger, because POSIX regex is always greedy.
        -:  451:		  // TODO: This could be slow.
        -:  452:		  if (*_M_states._M_get_sol_pos() == _BiIter()
        -:  453:		      || std::distance(_M_begin,
        -:  454:				       *_M_states._M_get_sol_pos())
        -:  455:			 < std::distance(_M_begin, _M_current))
        -:  456:		    {
        -:  457:		      *_M_states._M_get_sol_pos() = _M_current;
        -:  458:		      _M_results = _M_cur_results;
        -:  459:		    }
        -:  460:		}
        -:  461:	    }
        -:  462:	}
        -:  463:      else
        -:  464:	{
    #####:  465:	  if (_M_current == _M_begin
    #####:  466:	      && (_M_flags & regex_constants::match_not_null))
    %%%%%:  466-block  0
    %%%%%:  466-block  1
    %%%%%:  466-block  2
    %%%%%:  466-block  3
    %%%%%:  466-block  4
    #####:  467:	    return;
    %%%%%:  467-block  0
    #####:  468:	  if (__match_mode == _Match_mode::_Prefix || _M_current == _M_end)
    %%%%%:  468-block  0
    %%%%%:  468-block  1
    #####:  469:	    if (!_M_has_sol)
    %%%%%:  469-block  0
        -:  470:	      {
    #####:  471:		_M_has_sol = true;
    #####:  472:		_M_results = _M_cur_results;
    %%%%%:  472-block  0
        -:  473:	      }
        -:  474:	}
        -:  475:    }
------------------
        -:  476:
        -:  477:  template<typename _BiIter, typename _Alloc, typename _TraitsT,
        -:  478:	   bool __dfs_mode>
    #####:  479:    void _Executor<_BiIter, _Alloc, _TraitsT, __dfs_mode>::
        -:  480:    _M_handle_alternative(_Match_mode __match_mode, _StateIdT __i)
        -:  481:    {
    #####:  482:      const auto& __state = _M_nfa[__i];
        -:  483:
    #####:  484:      if (_M_nfa._M_flags & regex_constants::ECMAScript)
        -:  485:	{
        -:  486:	  // TODO: Fix BFS support. It is wrong.
    #####:  487:	  _M_dfs(__match_mode, __state._M_alt);
        -:  488:	  // Pick lhs if it matches. Only try rhs if it doesn't.
    #####:  489:	  if (!_M_has_sol)
    #####:  490:	    _M_dfs(__match_mode, __state._M_next);
        -:  491:	}
        -:  492:      else
        -:  493:	{
        -:  494:	  // Try both and compare the result.
        -:  495:	  // See "case _S_opcode_accept:" handling above.
    #####:  496:	  _M_dfs(__match_mode, __state._M_alt);
    #####:  497:	  auto __has_sol = _M_has_sol;
    #####:  498:	  _M_has_sol = false;
    #####:  499:	  _M_dfs(__match_mode, __state._M_next);
    #####:  500:	  _M_has_sol |= __has_sol;
        -:  501:	}
    #####:  502:    }
------------------
_ZNSt8__detail9_ExecutorIPKcSaINSt7__cxx119sub_matchIS2_EEENS3_12regex_traitsIcEELb1EE21_M_handle_alternativeENS9_11_Match_modeEl:
    #####:  479:    void _Executor<_BiIter, _Alloc, _TraitsT, __dfs_mode>::
        -:  480:    _M_handle_alternative(_Match_mode __match_mode, _StateIdT __i)
        -:  481:    {
    #####:  482:      const auto& __state = _M_nfa[__i];
    %%%%%:  482-block  0
        -:  483:
    #####:  484:      if (_M_nfa._M_flags & regex_constants::ECMAScript)
        -:  485:	{
        -:  486:	  // TODO: Fix BFS support. It is wrong.
    #####:  487:	  _M_dfs(__match_mode, __state._M_alt);
    %%%%%:  487-block  0
        -:  488:	  // Pick lhs if it matches. Only try rhs if it doesn't.
    #####:  489:	  if (!_M_has_sol)
    #####:  490:	    _M_dfs(__match_mode, __state._M_next);
    %%%%%:  490-block  0
        -:  491:	}
        -:  492:      else
        -:  493:	{
        -:  494:	  // Try both and compare the result.
        -:  495:	  // See "case _S_opcode_accept:" handling above.
    #####:  496:	  _M_dfs(__match_mode, __state._M_alt);
    %%%%%:  496-block  0
    #####:  497:	  auto __has_sol = _M_has_sol;
    #####:  498:	  _M_has_sol = false;
    #####:  499:	  _M_dfs(__match_mode, __state._M_next);
    #####:  500:	  _M_has_sol |= __has_sol;
        -:  501:	}
    #####:  502:    }
------------------
_ZNSt8__detail9_ExecutorIPKcSaINSt7__cxx119sub_matchIS2_EEENS3_12regex_traitsIcEELb0EE21_M_handle_alternativeENS9_11_Match_modeEl:
    #####:  479:    void _Executor<_BiIter, _Alloc, _TraitsT, __dfs_mode>::
        -:  480:    _M_handle_alternative(_Match_mode __match_mode, _StateIdT __i)
        -:  481:    {
    #####:  482:      const auto& __state = _M_nfa[__i];
    %%%%%:  482-block  0
        -:  483:
    #####:  484:      if (_M_nfa._M_flags & regex_constants::ECMAScript)
        -:  485:	{
        -:  486:	  // TODO: Fix BFS support. It is wrong.
    #####:  487:	  _M_dfs(__match_mode, __state._M_alt);
    %%%%%:  487-block  0
        -:  488:	  // Pick lhs if it matches. Only try rhs if it doesn't.
    #####:  489:	  if (!_M_has_sol)
    #####:  490:	    _M_dfs(__match_mode, __state._M_next);
    %%%%%:  490-block  0
        -:  491:	}
        -:  492:      else
        -:  493:	{
        -:  494:	  // Try both and compare the result.
        -:  495:	  // See "case _S_opcode_accept:" handling above.
    #####:  496:	  _M_dfs(__match_mode, __state._M_alt);
    %%%%%:  496-block  0
    #####:  497:	  auto __has_sol = _M_has_sol;
    #####:  498:	  _M_has_sol = false;
    #####:  499:	  _M_dfs(__match_mode, __state._M_next);
    #####:  500:	  _M_has_sol |= __has_sol;
        -:  501:	}
    #####:  502:    }
------------------
        -:  503:
        -:  504:  template<typename _BiIter, typename _Alloc, typename _TraitsT,
        -:  505:	   bool __dfs_mode>
     181*:  506:    void _Executor<_BiIter, _Alloc, _TraitsT, __dfs_mode>::
        -:  507:    _M_dfs(_Match_mode __match_mode, _StateIdT __i)
        -:  508:    {
     181*:  509:      if (_M_states._M_visited(__i))
    #####:  510:	return;
        -:  511:
     181*:  512:      switch (_M_nfa[__i]._M_opcode())
        -:  513:	{
      52*:  514:	case _S_opcode_repeat:
      52*:  515:	  _M_handle_repeat(__match_mode, __i); break;
      29*:  516:	case _S_opcode_subexpr_begin:
      29*:  517:	  _M_handle_subexpr_begin(__match_mode, __i); break;
      24*:  518:	case _S_opcode_subexpr_end:
      24*:  519:	  _M_handle_subexpr_end(__match_mode, __i); break;
    #####:  520:	case _S_opcode_line_begin_assertion:
    #####:  521:	  _M_handle_line_begin_assertion(__match_mode, __i); break;
    #####:  522:	case _S_opcode_line_end_assertion:
    #####:  523:	  _M_handle_line_end_assertion(__match_mode, __i); break;
    #####:  524:	case _S_opcode_word_boundary:
    #####:  525:	  _M_handle_word_boundary(__match_mode, __i); break;
    #####:  526:	case _S_opcode_subexpr_lookahead:
    #####:  527:	  _M_handle_subexpr_lookahead(__match_mode, __i); break;
      73*:  528:	case _S_opcode_match:
      73*:  529:	  _M_handle_match(__match_mode, __i); break;
    #####:  530:	case _S_opcode_backref:
    #####:  531:	  _M_handle_backref(__match_mode, __i); break;
       3*:  532:	case _S_opcode_accept:
       3*:  533:	  _M_handle_accept(__match_mode, __i); break;
    #####:  534:	case _S_opcode_alternative:
    #####:  535:	  _M_handle_alternative(__match_mode, __i); break;
        -:  536:	default:
        -:  537:	  __glibcxx_assert(false);
        -:  538:	}
        -:  539:    }
------------------
_ZNSt8__detail9_ExecutorIPKcSaINSt7__cxx119sub_matchIS2_EEENS3_12regex_traitsIcEELb1EE6_M_dfsENS9_11_Match_modeEl:
      181:  506:    void _Executor<_BiIter, _Alloc, _TraitsT, __dfs_mode>::
        -:  507:    _M_dfs(_Match_mode __match_mode, _StateIdT __i)
        -:  508:    {
      181:  509:      if (_M_states._M_visited(__i))
      181:  509-block  0
    #####:  510:	return;
    %%%%%:  510-block  0
        -:  511:
      181:  512:      switch (_M_nfa[__i]._M_opcode())
      181:  512-block  0
        -:  513:	{
       52:  514:	case _S_opcode_repeat:
       52:  515:	  _M_handle_repeat(__match_mode, __i); break;
       52:  515-block  0
       29:  516:	case _S_opcode_subexpr_begin:
       29:  517:	  _M_handle_subexpr_begin(__match_mode, __i); break;
       29:  517-block  0
       24:  518:	case _S_opcode_subexpr_end:
       24:  519:	  _M_handle_subexpr_end(__match_mode, __i); break;
       24:  519-block  0
    #####:  520:	case _S_opcode_line_begin_assertion:
    #####:  521:	  _M_handle_line_begin_assertion(__match_mode, __i); break;
    %%%%%:  521-block  0
    #####:  522:	case _S_opcode_line_end_assertion:
    #####:  523:	  _M_handle_line_end_assertion(__match_mode, __i); break;
    %%%%%:  523-block  0
    #####:  524:	case _S_opcode_word_boundary:
    #####:  525:	  _M_handle_word_boundary(__match_mode, __i); break;
    %%%%%:  525-block  0
    #####:  526:	case _S_opcode_subexpr_lookahead:
    #####:  527:	  _M_handle_subexpr_lookahead(__match_mode, __i); break;
    %%%%%:  527-block  0
       73:  528:	case _S_opcode_match:
       73:  529:	  _M_handle_match(__match_mode, __i); break;
       73:  529-block  0
    #####:  530:	case _S_opcode_backref:
    #####:  531:	  _M_handle_backref(__match_mode, __i); break;
    %%%%%:  531-block  0
        3:  532:	case _S_opcode_accept:
        3:  533:	  _M_handle_accept(__match_mode, __i); break;
        3:  533-block  0
    #####:  534:	case _S_opcode_alternative:
    #####:  535:	  _M_handle_alternative(__match_mode, __i); break;
    %%%%%:  535-block  0
        -:  536:	default:
        -:  537:	  __glibcxx_assert(false);
        -:  538:	}
        -:  539:    }
------------------
_ZNSt8__detail9_ExecutorIPKcSaINSt7__cxx119sub_matchIS2_EEENS3_12regex_traitsIcEELb0EE6_M_dfsENS9_11_Match_modeEl:
    #####:  506:    void _Executor<_BiIter, _Alloc, _TraitsT, __dfs_mode>::
        -:  507:    _M_dfs(_Match_mode __match_mode, _StateIdT __i)
        -:  508:    {
    #####:  509:      if (_M_states._M_visited(__i))
    %%%%%:  509-block  0
    #####:  510:	return;
    %%%%%:  510-block  0
        -:  511:
    #####:  512:      switch (_M_nfa[__i]._M_opcode())
    %%%%%:  512-block  0
        -:  513:	{
    #####:  514:	case _S_opcode_repeat:
    #####:  515:	  _M_handle_repeat(__match_mode, __i); break;
    %%%%%:  515-block  0
    #####:  516:	case _S_opcode_subexpr_begin:
    #####:  517:	  _M_handle_subexpr_begin(__match_mode, __i); break;
    %%%%%:  517-block  0
    #####:  518:	case _S_opcode_subexpr_end:
    #####:  519:	  _M_handle_subexpr_end(__match_mode, __i); break;
    %%%%%:  519-block  0
    #####:  520:	case _S_opcode_line_begin_assertion:
    #####:  521:	  _M_handle_line_begin_assertion(__match_mode, __i); break;
    %%%%%:  521-block  0
    #####:  522:	case _S_opcode_line_end_assertion:
    #####:  523:	  _M_handle_line_end_assertion(__match_mode, __i); break;
    %%%%%:  523-block  0
    #####:  524:	case _S_opcode_word_boundary:
    #####:  525:	  _M_handle_word_boundary(__match_mode, __i); break;
    %%%%%:  525-block  0
    #####:  526:	case _S_opcode_subexpr_lookahead:
    #####:  527:	  _M_handle_subexpr_lookahead(__match_mode, __i); break;
    %%%%%:  527-block  0
    #####:  528:	case _S_opcode_match:
    #####:  529:	  _M_handle_match(__match_mode, __i); break;
    %%%%%:  529-block  0
    #####:  530:	case _S_opcode_backref:
    #####:  531:	  _M_handle_backref(__match_mode, __i); break;
    %%%%%:  531-block  0
    #####:  532:	case _S_opcode_accept:
    #####:  533:	  _M_handle_accept(__match_mode, __i); break;
    %%%%%:  533-block  0
    #####:  534:	case _S_opcode_alternative:
    #####:  535:	  _M_handle_alternative(__match_mode, __i); break;
    %%%%%:  535-block  0
        -:  536:	default:
        -:  537:	  __glibcxx_assert(false);
        -:  538:	}
        -:  539:    }
------------------
        -:  540:
        -:  541:  // Return whether now is at some word boundary.
        -:  542:  template<typename _BiIter, typename _Alloc, typename _TraitsT,
        -:  543:	   bool __dfs_mode>
    #####:  544:    bool _Executor<_BiIter, _Alloc, _TraitsT, __dfs_mode>::
        -:  545:    _M_word_boundary() const
        -:  546:    {
    #####:  547:      if (_M_current == _M_begin && (_M_flags & regex_constants::match_not_bow))
    #####:  548:	return false;
    #####:  549:      if (_M_current == _M_end && (_M_flags & regex_constants::match_not_eow))
    #####:  550:	return false;
        -:  551:
    #####:  552:      bool __left_is_word = false;
    #####:  553:      if (_M_current != _M_begin
    #####:  554:	  || (_M_flags & regex_constants::match_prev_avail))
        -:  555:	{
    #####:  556:	  auto __prev = _M_current;
    #####:  557:	  if (_M_is_word(*std::prev(__prev)))
    #####:  558:	    __left_is_word = true;
        -:  559:	}
    #####:  560:      bool __right_is_word =
    #####:  561:        _M_current != _M_end && _M_is_word(*_M_current);
        -:  562:
    #####:  563:      return __left_is_word != __right_is_word;
        -:  564:    }
        -:  565:} // namespace __detail
        -:  566:
        -:  567:_GLIBCXX_END_NAMESPACE_VERSION
        -:  568:} // namespace
