        -:    0:Source:/home/minerkow/Рабочий стол/2nd_Course/Matrix/Graph.hpp
        -:    0:Graph:/home/minerkow/Рабочий стол/2nd_Course/Matrix/cmake-build-debug/CMakeFiles/Matrix.dir/main.gcno
        -:    0:Data:/home/minerkow/Рабочий стол/2nd_Course/Matrix/cmake-build-debug/CMakeFiles/Matrix.dir/main.gcda
        -:    0:Runs:1
        -:    1:#pragma once
        -:    2:#include "Matrix.hpp"
        -:    3:#include <regex>
        -:    4:#include <set>
        -:    5:
        -:    6:
        -:    7:
        -:    8:namespace grph {
        -:    9:    class RTGraph_t final{
        -:   10:        using MatrCoord_t = std::pair<size_t, size_t>;
        -:   11:        using EdgeInfo_t = std::pair<double, double>;
        -:   12:    public:
        -:   13:
        -:   14:        RTGraph_t(std::istream& is);
        -:   15:        std::vector<double> Calculate_Potential();
        -:   16:        std::vector<std::pair<MatrCoord_t, double>> Calculate_Amperage(std::ostream& os);
        -:   17:        mtrx::Matrix_t<int> Find_Cycles();
        -:   18:        size_t Num_Nodes();
        -:   19:        size_t Num_Edges();
        -:   20:
        -:   21:    private:
        -:   22:        void Depth_Walk(mtrx::Matrix_t<int>& contourMtrx, std::set<size_t>& climbedNodes, mtrx::Matrix_t<int> newRow,
        -:   23:                        const size_t currentNode);
        -:   24:
        -:   25:        mtrx::Matrix_t<double> incMtrx_;
        -:   26:        std::vector<double> resistMtrx_;
        -:   27:        mtrx::Matrix_t<double> emfMtrx_;
        -:   28:        std::vector<size_t> loops_;
        -:   29:    };
        -:   30:
        -:   31:
        -:   32:    std::vector<double> Gaussian_Method(mtrx::Matrix_t<double> mtrx);
        -:   33:    size_t Sequential_Elim(mtrx::Matrix_t<double> &mtrx);
        -:   34:    std::vector<double> Reverse_Sub(mtrx::Matrix_t<double> &mtrx);
        -:   35:}
        -:   36:
        1:   37:grph::RTGraph_t::RTGraph_t(std::istream &is) {
        1:   37-block  0
    $$$$$:   37-block  1
    $$$$$:   37-block  2
    $$$$$:   37-block  3
    $$$$$:   37-block  4
        2:   38:    std::string line;
    $$$$$:   38-block  0
        2:   39:    std::cmatch result;
    $$$$$:   39-block  0
        1:   40:    size_t maxNumNode = 0;
        2:   41:    std::vector<std::pair<MatrCoord_t, EdgeInfo_t>> matrInfo{};
    $$$$$:   41-block  0
        -:   42:    const std::regex regular("(\\d+)"
        -:   43:                             "(\\s*\\-\\-\\s*)"
        -:   44:                             "(\\d+)"
        -:   45:                             "(\\s*[,]\\s*)"
        -:   46:                             "(\\d+[.]?\\d*)"
        -:   47:                             "(\\s*[;]\\s*)"
        -:   48:                             "((\\-?\\d+([.]\\d)?)"
        -:   49:                             "([V]?))?"
        2:   50:                       );
        1:   50-block  0
    $$$$$:   50-block  1
        4:   51:    while (getline(is, line, '\n')) {
        4:   51-block  0
        4:   51-block  1
        4:   51-block  2
        -:   52:        size_t grNode1, grNode2;
        3:   53:        EdgeInfo_t rv;
        3:   54:        if (std::regex_search(line.c_str(), result, regular)) {
        3:   54-block  0
        3:   54-block  1
        3:   55:            grNode1 = std::atoi(result[1].str().c_str());
        3:   55-block  0
        3:   55-block  1
        3:   55-block  2
        3:   56:            grNode2 = std::atoi(result[3].str().c_str());
        3:   56-block  0
        3:   56-block  1
        -:   57:
        3:   58:            maxNumNode = std::max(maxNumNode, std::max(grNode1, grNode2));
        -:   59:
        3:   60:            rv.first = std::atof(result[5].str().c_str());
        3:   60-block  0
        3:   60-block  1
        3:   61:            if (result.size() < 8) {
    #####:   62:                rv.second = 0.0;
    %%%%%:   62-block  0
        -:   63:            } else {
        3:   64:                rv.second = std::atof(result[7].str().c_str());
        3:   64-block  0
        3:   64-block  1
        3:   64-block  2
        -:   65:            }
        3:   66:            matrInfo.push_back({{grNode1, grNode2}, rv});
        3:   66-block  0
        3:   66-block  1
    $$$$$:   66-block  2
    $$$$$:   66-block  3
        -:   67:        } else {
    #####:   68:            throw std::regex_error(std::regex_constants::error_collate);
    %%%%%:   68-block  0
    %%%%%:   68-block  1
    $$$$$:   68-block  2
        -:   69:        }
        -:   70:    }
        -:   71:
        1:   72:    incMtrx_ = mtrx::Matrix_t<int>(maxNumNode, matrInfo.size());
        1:   72-block  0
        1:   72-block  1
        1:   72-block  2
    $$$$$:   72-block  3
    $$$$$:   72-block  4
        1:   73:    resistMtrx_ = std::vector<double>(matrInfo.size());
        1:   73-block  0
    $$$$$:   73-block  1
    $$$$$:   73-block  2
        1:   74:    emfMtrx_ = mtrx::Matrix_t<double>(matrInfo.size(), 1);
        1:   74-block  0
        -:   75:
        4:   76:    for (size_t i = 0; i < matrInfo.size(); ++i) {
        4:   76-block  0
        3:   77:        incMtrx_[matrInfo[i].first.first - 1][i] += 1;
        3:   77-block  0
        3:   77-block  1
        3:   78:        incMtrx_[matrInfo[i].first.second - 1][i] += -1;
        3:   78-block  0
        3:   78-block  1
        3:   79:        if (matrInfo[i].first.first == matrInfo[i].first.second) {
        3:   79-block  0
    #####:   80:            incMtrx_[matrInfo[i].first.first - 1][i] = 0;
    %%%%%:   80-block  0
    %%%%%:   80-block  1
    #####:   81:            loops_.emplace_back(matrInfo[i].first.first);
    %%%%%:   81-block  0
        -:   82:        }
        3:   83:        resistMtrx_[i] = matrInfo[i].second.first;
        3:   83-block  0
        3:   84:        emfMtrx_[i][0] = matrInfo[i].second.second;
        3:   84-block  0
        3:   84-block  1
        -:   85:    }
        -:   86:#ifdef DEBUG
        -:   87:    std::cout << incMtrx_ << std::endl
        -:   88:              << conductMtrx_ << std::endl
        -:   89:              << emfMtrx_ << std::endl;
        -:   90:#endif
        1:   91:}
        -:   92:
    #####:   93:std::vector<double> grph::RTGraph_t::Calculate_Potential() {
    #####:   94:    mtrx::Matrix_t<double> incMtrxT = incMtrx_.Transposition();
    %%%%%:   94-block  0
    $$$$$:   94-block  1
    #####:   95:    mtrx::Matrix_t<double> conductMtrx{mtrx::ConvertDiagMtrx(resistMtrx_)};
    %%%%%:   95-block  0
    $$$$$:   95-block  1
    #####:   96:    for (size_t i = 0; i < conductMtrx.Num_Columns(); ++i) {
    %%%%%:   96-block  0
    %%%%%:   96-block  1
    #####:   97:        conductMtrx[i][i] = 1 / conductMtrx[i][i];
    %%%%%:   97-block  0
    %%%%%:   97-block  1
    %%%%%:   97-block  2
    %%%%%:   97-block  3
    %%%%%:   97-block  4
        -:   98:    }
    #####:   99:    mtrx::Matrix_t<double> incMtrxWithoutMaxNode = incMtrx_.Without_Row(incMtrx_.Num_Rows() - 1);
    %%%%%:   99-block  0
    $$$$$:   99-block  1
        -:  100:
    #####:  101:    mtrx::Matrix_t<double> systEq = incMtrxWithoutMaxNode.Matrix_Mult(conductMtrx).Matrix_Mult(incMtrxWithoutMaxNode);
    %%%%%:  101-block  0
    %%%%%:  101-block  1
    $$$$$:  101-block  2
    $$$$$:  101-block  3
        -:  102:
    #####:  103:    mtrx::Matrix_t<double> freeColumn = - incMtrx_.Matrix_Mult(conductMtrx).Matrix_Mult(emfMtrx_);
    %%%%%:  103-block  0
    %%%%%:  103-block  1
    %%%%%:  103-block  2
    $$$$$:  103-block  3
    $$$$$:  103-block  4
    $$$$$:  103-block  5
        -:  104:#ifdef DEBUG
        -:  105:    std::cout << systEq << std::endl << freeColumn << std::endl;
        -:  106:#endif
    #####:  107:    std::vector<double> res = Gaussian_Method(systEq.Connect_Column(freeColumn));
    %%%%%:  107-block  0
    $$$$$:  107-block  1
    #####:  108:    return res;
    %%%%%:  108-block  0
        -:  109:}
        -:  110:
    #####:  111:size_t grph::RTGraph_t::Num_Nodes() {
    #####:  112:    return incMtrx_.Num_Rows() + 1;
    %%%%%:  112-block  0
        -:  113:}
        -:  114:
        5:  115:size_t grph::RTGraph_t::Num_Edges() {
        5:  116:    return emfMtrx_.Num_Rows();
        5:  116-block  0
        -:  117:}
        -:  118:
    #####:  119:std::vector<std::pair<grph::RTGraph_t::MatrCoord_t, double>> grph::RTGraph_t::Calculate_Amperage(std::ostream &os) {
    #####:  120:    std::vector<std::pair<MatrCoord_t, double>> res(Num_Edges());
    %%%%%:  120-block  0
    %%%%%:  120-block  1
    $$$$$:  120-block  2
        -:  121:
    #####:  122:}
        -:  123:
        1:  124:mtrx::Matrix_t<int> grph::RTGraph_t::Find_Cycles() {
        1:  125:        mtrx::Matrix_t<int> contourMtrx;
        1:  125-block  0
        2:  126:        mtrx::Matrix_t<int> newRow{1, Num_Edges()};
        1:  126-block  0
    $$$$$:  126-block  1
        2:  127:        std::set<size_t> climbedNodes;
        1:  127-block  0
        1:  127-block  1
    $$$$$:  127-block  2
        1:  128:        size_t currentNode = 1;
        1:  129:        Depth_Walk( contourMtrx, climbedNodes, newRow, currentNode);
        1:  129-block  0
        1:  129-block  1
    $$$$$:  129-block  2
    $$$$$:  129-block  3
        1:  130:        std::cout << contourMtrx;
        2:  131:        return contourMtrx;
        1:  131-block  0
        1:  131-block  1
        -:  132:}
        -:  133:
        1:  134:void grph::RTGraph_t::Depth_Walk( mtrx::Matrix_t<int>& contourMtrx, std::set<size_t>& climbedNodes,
        -:  135:                                  mtrx::Matrix_t<int> newRow, const size_t currentNode)
        -:  136:{
        1:  137:    if (climbedNodes.find(currentNode) != climbedNodes.end()) {
        1:  137-block  0
        1:  137-block  1
    $$$$$:  137-block  2
    #####:  138:        return;
    %%%%%:  138-block  0
        -:  139:    }
        1:  140:    climbedNodes.insert(currentNode);
        1:  140-block  0
        4:  141:    for (size_t i = 0; i < Num_Edges(); ++i) {
        4:  141-block  0
        3:  141-block  1
        3:  142:        if (incMtrx_[currentNode - 1][i] != 0) {
        3:  142-block  0
        2:  143:            size_t j = 0;
        2:  143-block  0
        5:  144:            while (incMtrx_[j][i] != -incMtrx_[currentNode - 1][i]) {
        5:  144-block  0
        3:  145:                j++;
        3:  145-block  0
        -:  146:            }
        2:  147:            if (climbedNodes.find(j+1) != climbedNodes.end()) {
        2:  147-block  0
        2:  147-block  1
    $$$$$:  147-block  2
    $$$$$:  147-block  3
    #####:  148:                newRow[0][i] = incMtrx_[currentNode - 1][i];
    %%%%%:  148-block  0
    #####:  149:                Depth_Walk( contourMtrx, climbedNodes, newRow, j + 1);
    %%%%%:  149-block  0
    $$$$$:  149-block  1
        -:  150:            } else {
        2:  151:                contourMtrx.Add_Row(newRow);
        2:  151-block  0
        2:  152:                std::cout << contourMtrx << std::endl << std::endl;
        -:  153:            }
        -:  154:        }
        -:  155:    }
        -:  156:}
        -:  157:
    #####:  158:std::vector<double> grph::Gaussian_Method(mtrx::Matrix_t<double> mtrx) {
    #####:  159:    if (mtrx.Num_Rows() + 1 != mtrx.Num_Columns()) {
    %%%%%:  159-block  0
        -:  160:        //have not solution
        -:  161:        //TODO::
        -:  162:    }
    #####:  163:    size_t n = mtrx.Num_Rows();
    %%%%%:  163-block  0
    #####:  164:    int singularFlag = grph::Sequential_Elim(mtrx);
        -:  165:
    #####:  166:    if (singularFlag != -1)
        -:  167:    {
    #####:  168:        printf("Singular Matrix.\n");
    %%%%%:  168-block  0
        -:  169:
    #####:  170:        if (mtrx[singularFlag][n])
    #####:  171:            printf("Inconsistent System.");
    %%%%%:  171-block  0
        -:  172:        else
    #####:  173:            printf("May have infinitely many "
    %%%%%:  173-block  0
        -:  174:                   "solutions.");
        -:  175:
        -:  176:        //TODO
        -:  177:    }
        -:  178:
    #####:  179:    return grph::Reverse_Sub(mtrx);
    %%%%%:  179-block  0
        -:  180:}
        -:  181:
    #####:  182:std::vector<double> grph::Reverse_Sub(mtrx::Matrix_t<double> &mtrx) {
    #####:  183:    std::vector<double> result(mtrx.Num_Rows() + 1);
    %%%%%:  183-block  0
    $$$$$:  183-block  1
    #####:  184:    for (int i = mtrx.Num_Rows() - 1; i >= 0; --i)
    %%%%%:  184-block  0
    %%%%%:  184-block  1
        -:  185:    {
    #####:  186:        result[i] = mtrx[i][mtrx.Num_Rows()];
    %%%%%:  186-block  0
    %%%%%:  186-block  1
    %%%%%:  186-block  2
        -:  187:
    #####:  188:        for (int j = i + 1; j < mtrx.Num_Rows(); ++j)
    %%%%%:  188-block  0
    #####:  189:            result[i] -= mtrx[i][j] * result[j];
    %%%%%:  189-block  0
    %%%%%:  189-block  1
    %%%%%:  189-block  2
        -:  190:
    #####:  191:        if (!mtrx::Double_Equal(mtrx[i][i], 0)) {
    %%%%%:  191-block  0
    %%%%%:  191-block  1
    %%%%%:  191-block  2
    #####:  192:            result[i] = result[i] / mtrx[i][i];
    %%%%%:  192-block  0
    %%%%%:  192-block  1
    %%%%%:  192-block  2
        -:  193:        }
        -:  194:    }
        -:  195:
    #####:  196:    return result;
    %%%%%:  196-block  0
    %%%%%:  196-block  1
        -:  197:}
        -:  198:
    #####:  199:size_t grph::Sequential_Elim(mtrx::Matrix_t<double> &mtrx) {
    #####:  200:    for (int k = 0; k < mtrx.Num_Rows(); ++k)
    %%%%%:  200-block  0
    %%%%%:  200-block  1
    %%%%%:  200-block  2
        -:  201:    {
    #####:  202:        int iMax = k;
    #####:  203:        int vMax = mtrx[iMax][k];
    %%%%%:  203-block  0
        -:  204:
    #####:  205:        for (int i = k + 1; i < mtrx.Num_Rows(); ++i) {
    %%%%%:  205-block  0
    %%%%%:  205-block  1
    #####:  206:            if (std::abs(mtrx[i][k]) > vMax) {
    %%%%%:  206-block  0
    #####:  207:                vMax = mtrx[i][k];
    %%%%%:  207-block  0
    #####:  208:                iMax = i;
        -:  209:            }
        -:  210:        }
        -:  211:
    #####:  212:        if (iMax != k)
    %%%%%:  212-block  0
    #####:  213:            mtrx.Swap_Rows(k, iMax);
    %%%%%:  213-block  0
        -:  214:
    #####:  215:        for (int i = k + 1; i < mtrx.Num_Rows(); ++i)
    %%%%%:  215-block  0
    %%%%%:  215-block  1
        -:  216:        {
    #####:  217:            if (!mtrx::Double_Equal(mtrx[k][k], 0)) {
    %%%%%:  217-block  0
    #####:  218:                double f = mtrx[i][k] / mtrx[k][k];
    %%%%%:  218-block  0
    #####:  219:                for (int j = k + 1; j < mtrx.Num_Columns(); ++j)
    %%%%%:  219-block  0
    #####:  220:                    mtrx[i][j] -= mtrx[k][j] * f;
    %%%%%:  220-block  0
        -:  221:            }
    #####:  222:            mtrx[i][k] = 0;
    %%%%%:  222-block  0
        -:  223:        }
        -:  224:    }
    #####:  225:    return -1;
    %%%%%:  225-block  0
        -:  226:}
        -:  227:
        -:  228:template <typename T>
        -:  229:std::ostream& operator<<(std::ostream& os, std::vector<T>& vec) {
        -:  230:    os << " {";
        -:  231:    for (auto& it : vec) {
        -:  232:        os << it << " ";
        -:  233:    }
        -:  234:    os << "}";
        -:  235:    return os;
        -:  236:}
        -:  237:
